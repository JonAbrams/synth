<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta description="Synth is a back-end web framework designed to make (Angular|Ember|Backbone)JS web apps easy to create and manage."><title>Synth - The back-end web framework designed to make
(Angular|Ember|Backbone)JS web apps easy to create and manage.</title><link rel="stylesheet" href="//cdn.jsdelivr.net/bootstrap/3.1/css/bootstrap.min.css"><link rel="stylesheet" href="/bower_components/prismjs/prism.css"><link rel="stylesheet" href="/css/main.css"><link rel="icon" type="image/png" href="/favicon.png"></head><body data-spy="scroll" data-target=".toc"><nav class="navbar navbar-default navbar-static-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#synth-links" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Synth</a></div><div id="synth-links" class="collapse navbar-collapse navbar-right"><ul class="nav navbar-nav"><li class="docs"><a href="/docs">Docs</a></li><li class="tutorial"><a href="/tutorial">Tutorial</a></li><li class="examples"><a href="/examples">Examples</a></li><li class="source"><a href="https://github.com/JonAbrams/synth">Source</a></li></ul></div></div></nav><div class="container"><div class="row"><div class="col-md-3"><div class="toc"><h2>教程</h2><ul class="nav"><li class="section"><a href="#intro">简介</a></li><li class="section"><a href="#setup">创建</a><ul class="nav"><li><a href="#dependencies">依赖关系</a></li><li><a href="#install">安装 Synth</a></li><li><a href="#create-app">创建一个新的应用</a></li><li><a href="#starting">运行这个应用</a></li><li><a href="#populate-db">预配置数据库</a></li></ul></li><li class="section"><a href="#publish">为“tweet”添加功能</a><ul class="nav"><li><a href="#create-post-method">创建接收 post 请求的方法</a></li><li><a href="#create-publish-method">在 tweetsController 中创建一个发布方法</a></li><li><a href="#add-textarea-and-button">添加 textarea 和 button 表单控件</a></li></ul></li><li class="section"><a href="#enable-links-to-tweets">为每条推文创建单独的链接</a><ul class="nav"><li><a href="#create-get-method">创建接收 GET 请求的方法</a></li><li><a href="#create-tweet-controller">创建一个新的 tweetController 控制器</a></li><li><a href="#create-tweet-view">创建 tweet 视图并且添加超链接</a></li></ul></li></ul></div></div><div class="contents col-md-9"><p><div class="language-toggle">
  Languages / 语言
  <ul>
    <li><a href="/tutorial">English</a></li>
    <li><a href="/tutorial/cn">简体中文</a></li>
  </ul>
</div></p>
<p><div id="intro"></div></p>
<h1>简介</h1><p>看完这篇教程后，你就会知道如何给用 <code>Synth</code> 创建的默认应用添加功能了。</p>
<p>教程中的示例应用只是一个非常简陋的Twitter，简陋到只具有推文列表的显示功能（但我们会在后面慢慢为它添加功能）。</p>
<p>此教程将会指导你完成：</p>
<ol>
<li>安装 <code>Synth</code>；</li>
<li>创建你的第一个项目。</li>
</ol>
<p>然后我们将会为这个应用添加以下这些功能：</p>
<ul>
<li>能够发布新推文；</li>
<li>能够链接到某条推文单独的页面；</li>
<li>能够以非匿名状态发送推文。</li>
</ul>
<p><div id="setup"></div></p>
<h1>创建</h1><p><div id="dependencies"></div></p>
<h2>依赖关系</h2><p>在开始使用 <code>synth</code> 之前，你需要安装下面这些库以保证能够正常使用 <code>synth</code>：</p>
<ul>
<li>Node 版本0.10.0及以上 - <a href="http://nodejs.org/">免费获取</a></li>
<li>NPM 版本1.3及以上（现在它应该会在安装Node的时候一起被安装）</li>
<li>MongoDB - <a href="https://www.mongodb.org/">免费获取</a> - 安装完成之后别忘记在后台启动好它</li>
</ul>
<p><div id="install"></div></p>
<h2>安装 Synth</h2><p>我们可以通过NPM去获取 <code>synth</code> 。将它安装在全局环境中以便我们能通过命令行进行调用：</p>
<pre><code class="language-bash">npm install -g synth
</code></pre>
<p><strong>备注</strong>：当你执行上述代码的时候，如果收到了权限错误之类的提示，你可能需要使用 <code>sudo npm install -g synth</code> 来进行安装。</p>
<p><div id="create-app"></div></p>
<h2>创建一个新的应用</h2><pre><code class="language-bash">synth new my_app
</code></pre>
<p>这条命令会把新应用创建到 <code>my_app</code> 文件夹中，当然你也可以将它换成任何你喜欢的名字。</p>
<pre><code class="language-bash">cd my_app # 切换到你新应用的根目录中
synth install -b # 安装第三方的后端库（通过npm）
synth install -f # 安装第三方的前端库（通过bower）
</code></pre>
<p>然后进入应用文件夹并安装你需要的第三方前端库和后端库<em>[译注：由于这两个命令分别是基于npm和bower的，所以依赖库的配置文件都会使用它们各自的文件，分别是 <code>back/package.json</code> 和 <code>front/bower.json</code>]</em>。</p>
<p>尽管你已经将 <code>synth</code> 装在了全局环境中，但为了能够在命令行中使用它，我们还需要在项目中安装它。执行 <code>synth install -b</code> 来安装它<em>[译注：这时候它去查找的其实就是 <code>back/package.json</code> 中的依赖关系，在使用 <code>synth</code> 生成应用的时候它就默认把自己也给放进这个依赖关系中了]</em>。</p>
<p><strong>备注</strong>：</p>
<ul>
<li>后端依赖库将会安装在 <code>my_app/back/node_modules</code> 文件夹中。</li>
<li>前端依赖库将会安装在 <code>my_app/front/bower_components</code> 文件夹中。</li>
</ul>
<p><div id="starting"></div></p>
<h2>运行这个应用</h2><p>执行 <code>synth server</code> 或者 <code>synth s</code> 就可以启动这个应用了。</p>
<p>若要以生产模式（即所有的源文件都被压缩及合并）运行这个应用，需要将 <em>NODE_ENV</em> 这个环境变量设置为“production”，然后执行 <code>synth server</code> <em>[译注：在启动服务器命令的前面加上  <code>NODE_ENV=production</code> 来将环境变量改变]</em>，或者直接执行 <code>synth prod</code> 命令<em>[译注：执行这个命令就等同于将环境变量设置为 <code>production</code> 之后再执行 <code>synth server</code> ]</em>。</p>
<p>你可以通过 <em>-p</em> 传递 <em>PORT</em> 参数来设置服务器的监听端口，例如： <code>synth s -p 3001</code>。3000 是 <code>synth</code> 的默认监听端口。</p>
<p><div id="populate-db"></div></p>
<h2>预配置数据库</h2><p>当你将浏览器地址指向 <a href="http://localhost:3000/tweets/">http://localhost:3000/tweets/</a> 的时候，应该能够在页面中间看见“Tweets”这个标题了。但是传说中的 &quot;tweets&quot;（推文） 在哪里呢？</p>
<p>不用担心，<code>synth</code> 已经帮你创建了一个能够自动向数据库添加一些推文的脚本。</p>
<p>再打开一个终端窗口，运行这个脚本来生成推文：</p>
<pre><code class="language-bash">node back/generateTweets.js
</code></pre>
<p>等它执行完毕后刷新这个应用，应该就能看到20条推文被显示出来了。</p>
<p><div id="publish"></div></p>
<h1>为“tweet”添加功能</h1><p>现在我们已经能看到推文被显示出来了，但如果访问这个网站的人也能够发送推文的话，是不是就更加美妙了呢。</p>
<p>通过以下三个步骤来实现这个功能：</p>
<ol>
<li>在后端创建一个接收 <em>post</em> 请求的方法；</li>
<li>在前端的 <em>tweetsController</em> 中创建一个发布推文的方法；</li>
<li>在前端页面中添加一个 textarea 文本框和一个发布按钮。</li>
</ol>
<p><div id="create-post-method"></div></p>
<h2>创建接收 <em>post</em> 请求的方法</h2><p>我们需要提供一个 API 接口让这个应用去请求，它的作用是在数据库中创建一条新的推文。</p>
<p>在 <code>synth</code> 中添加接口的方法，就是在用来与接口交互的资源文件夹[译注：就是 <code>back/resource/</code> 文件夹]中创建一个公共方法。在这个例子中，我们将会在 <code>back/resources/tweets/</code> 文件夹里的 <em>a.js</em> 中添加一个接收 <code>post</code> 请求的方法。</p>
<p><strong>备注</strong>：<em>.js</em> 文件的命名跟 <code>synth</code> 的运行没有任何关系，你可以选择任何一个符合你需求的名称。但是在 <code>back/resources/</code> 中的文件夹名称和 <code>synth</code> 是有关系的，它们决定了 <code>synth</code> 监听的路由地址。</p>
<p>在 <code>my_app/back/resources/tweets/createTweets.js</code> 这个文件中添加以下代码：</p>
<pre><code class="language-javascript">exports.post = function (db, params) {
  if (!params.content) throw 422;

  return db.collection(&#39;tweets&#39;).insert({
    content: params.content.slice(0, 140),
    created_at: new Date()
  });
};
</code></pre>
<h4>说明</h4><p>你现在在 <code>/api/tweets</code> 这个路由上已经有了一个能够响应 <strong>POST</strong> 请求的处理程序。它通过这样的声明 <code>exports.post = function(db, params)</code> 来指定请求处理程序依赖于 <em>db</em> 和 <em>params</em> 服务（都是默认模板的一部分[译注：作者的意思应该是说这中声明方式是默认写法，不用刻意理会]）。<code>Synth</code> 将会在请求处理程序被调用的时候自动注入依赖[译注：即将db和params服务作为默认参数传入这个函数]。在执行的过程中，任何参数都会作为请求体的一部分被传入，可以通过 <em>params</em> 对象去获取这些参数，另外 <em>db</em> 对象将会提供进行数据库连接的组件。</p>
<p>如果请求体中没有附加任何内容，这段程序将会抛出 422 错误，也就是将响应状态码设置为 422 并且返回给客户端。相反，如果响应体中有内容，那么它将会在 mongoDB 中插入一个新的文档[译注：“文档”即推文实例，因为 mongoDB 是文档型数据库，所以这里称之为文档]。</p>
<p>也许你现在想知道：为什么这个函数会把对数据库的调用语句作为返回值呢？因为 <code>Synth</code> 内建了对 promise 的支持。意思是说，如果请求成功（即状态码为 200 ），你可以选择直接返回JSON数据，也可以选择返回一个 promise。而在这个应用中，<em>db</em> 提供了一个叫做 <a href="https://github.com/gordonmleigh/promised-mongo">promised-mongo</a> 的库，正如你在 <code>back/service/db.js</code> 中所能看到的那样，它被声明在了 <em>db</em> 这个服务中。它允许你和 mongoDB 进行交互并且将一个 promise 作为结果返回。如果返回值是一个 promise 的话，<code>synth</code> 将会等待这个 promise 被解决（即数据已经被写入到数据库中），然后将一个新的推文以JSON的形式和响应体一起返回给客户端。</p>
<p>如果不使用 <code>synth</code> 的 promise 特性及依赖注入，代码需要像下面这样写：</p>
<pre><code class="language-javascript">exports.post = function (req, res) {
  if (!req.body.content) return res.send(422);

  req.db.collection(&#39;tweets&#39;).insert({
    content: req.body.content.slice(0, 140),
    created_at: new Date()
  }, function (tweet) {
    res.send( JSON.stringify(tweet) );
  });
};
</code></pre>
<p>上述代码也能完成同样的功能，但代码行数会更加多一些。有人曾说过，代码越多也就意味着 bug 出现几率越高！</p>
<p><div id="create-publish-method"></div></p>
<h2>在 <em>tweetsController</em> 中创建一个发布方法</h2><p>现在我们已经把后端部分准备好了，如果想要通过发起 http 请求来向数据库添加推文的话，就需要在前端添加创建发送推文请求的 JS 代码。</p>
<p>找到 <code>my_app/front/controllers/tweets.js</code> ，在 <em>tweetsController</em> 中添加以下代码：</p>
<pre><code class="language-javascript">$scope.publish = function () {
  $http.post(&#39;/api/tweets&#39;, { content: $scope.newTweet })
  .success(function (tweet) {
    $scope.tweets.unshift(tweet);
  });
  $scope.newTweet = &#39;&#39;;
};
</code></pre>
<p>你还需要将 <em>$http</em> 服务注入给这个控制器（在代码的第 2 行）：</p>
<pre><code class="language-javascript">.controller(&#39;tweetsController&#39;, function ($scope, $http, data) {
</code></pre>
<h4>说明</h4><p>如果你很熟悉 AngularJS，将会非常容易理解上述代码。它向 <code>http://localhost:3000/api/tweets</code> 这个地址发起了一个 POST 请求，并携带了一串 JSON 数据（例如： <code>{&quot;content&quot;: &quot;An example tweet&quot;}</code>）。</p>
<p>和 <code>synth</code> 一样，AngularJS 也内建了对 promise 的支持。这个 post 请求就是一个 promise，一旦它成功地被解决，就会添加一条推文到列表中并呈现给用户[译注：即 post 请求成功的话就会调用 success 回调函数去添加推文]。</p>
<p>为了防止意外发送两条一模一样的推文，这段代码还会在 http 请求完成之前将 <em>newtweet</em> 这个变量清空。</p>
<p><div id="add-textarea-and-button"></div></p>
<h2>添加 textarea 和 button 表单控件</h2><p>现在我们已经完成了发布推文的前后端代码，但还剩下让用户能够输入他们的推文并且触发 <em>publish</em> 方法的 UI 及交互部分。</p>
<p>找到用来显示推文列表的视图模板，它位于 <code>my_app/front/html/tweets/getIndex.jade</code>。</p>
<p>打开这个文件并将以下代码添加到最顶部：</p>
<pre><code class="language-jade">textarea(ng-model=&quot;newTweet&quot;)
button(ng-click=&quot;publish()&quot;, ng-disabled=&quot;newTweet.length == 0&quot;) Publish
</code></pre>
<h4>说明</h4><p>也许你对 <a href="http://jade-lang.com/">jade</a> 并不熟悉，可一旦掌握了它的窍门，将能以更好的方式去编写 HTML。</p>
<p>上述 jade 代码添加了一个 textarea 文本框，并将它关联到了 <em>newTweet</em> 这个 Angular 数据模型上。接着它添加了一个 button 按钮并绑定了 click 事件，当点击这个按钮的时候就会去触发控制器中的 <em>publish</em> 方法。</p>
<p>进行到到这里，你已经能够发布一条新的推文了！</p>
<p><div id="enable-links-to-tweets"></div></p>
<h1>为每条推文创建单独的链接</h1><p>看到一条条推文被列出来真是太棒了，但如果你发现了一条很好的推文，想要把它的链接分享出去怎么办呢？</p>
<p>通过以下三个步骤来实现这个功能：</p>
<ol>
<li>在后端创建一个接收 <em>get</em> 请求的方法；</li>
<li>在前端创建一个新的 <em>tweetController</em> 控制器（注意这个 &quot;tweet&quot; 是单数而不是复数）；</li>
<li>为新的视图创建一个 html 模板。</li>
</ol>
<p><div id="create-get-method"></div></p>
<h2>创建接收 <em>GET</em> 请求的方法</h2><p>在 <code>back/resources/tweets/getTweets.js</code> 中已经有一个用于获取推文列表的 API 了。</p>
<p>继续创建一个获取单条推文的 API 接口，声明 <code>get</code> 方法并将它 exports 出去。</p>
<pre><code class="language-javascript">exports.get = function (params, db) {
  // 返回一个获取请求推文的 promise
  return db.collection(&#39;tweets&#39;).findOne({
    _id: db.ObjectId(params.id)
  });
}
</code></pre>
<h4>说明</h4><p>当这个处理 <code>get</code> 请求的函数被创建完成的时候，API 接口也就创建完成了，请求这个接口时需要传入一个推文 ID 作为参数。</p>
<p>上述代码将会监听客户端对 <code>/api/tweets/:id</code> 的请求。</p>
<p><code>Params</code> 服务会将请求的 URL 转换并将传入的推文 id 提供给我们使用。</p>
<p>请注意 <code>db.ObjectId</code> 只是一个用来将字符串转换为数据库特殊类型的方法。这个方法适用于 mongoDB。</p>
<p><div id="create-tweet-controller"></div></p>
<h2>创建一个新的 <em>tweetController</em> 控制器</h2><p>首页我们需要向你的 Angular 路由中添加一个新的路由配置。</p>
<p>在 <code>front/js/front-app.js</code> 中使用 <code>$routeProvider</code> 服务添加另外一个 <code>.when</code> 配置：</p>
<pre><code class="language-javascript">…
$routeProvider
.when(&#39;/tweets&#39;, {
  templateUrl: &#39;/html/tweets/getIndex.html&#39;,
  controller: &#39;tweetsController&#39;,
  resolve: {
    data: dataLoaderRunner
  }
})
.when(&#39;/tweets/:id&#39;, {
  templateUrl: &#39;/html/tweets/get.html&#39;,
  controller: &#39;tweetController&#39;,
  resolve: {
    data: dataLoaderRunner
  }
})
…
</code></pre>
<p>这样一来，当匹配到这个 URL 的时候，你的 AngularJS 应用就会去调用 <code>tweetController</code> 这个控制器。</p>
<p>现在你应该在 Angular 应用中添加这个控制器。</p>
<p><code>front/js/controllers/tweets.js</code>:</p>
<pre><code class="language-javascript">.controller(&#39;tweetsController&#39;, function ($scope, data) {
  $scope.tweets = data.tweets;
})
.controller(&#39;tweetController&#39;, function ($scope, data) {
  angular.extend($scope, data);
});
</code></pre>
<p>上述代码会将从 API 获得的数据拷贝到作用域中，这样一来，我们就能够在下一步的视图中去渲染它们了。</p>
<p><div id="create-tweet-view"></div></p>
<h2>创建 <em>tweet</em> 视图并且添加超链接</h2><p>创建一个新 html 文件作为视图：</p>
<p><code>front/html/tweets/get.html</code></p>
<pre><code class="language-html">&lt;div class=&quot;tweet&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    {{ content }}
  &lt;/div&gt;
  &lt;div class=&quot;date&quot;&gt;
    {{ created_at | date:&#39;medium&#39; }}
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>然后在 index 视图模板中给推文添加超链接：</p>
<p><code>front/html/tweets/getIndex.jade</code></p>
<pre><code class="language-javascript">ul.tweet-timeline
  li.tweet(ng-repeat=&quot;tweet in tweets&quot;)
    .content {{ tweet.content}}
    a(href=&quot;/tweets/{{ tweet._id }}&quot;)
      .date {{ tweet.created_at | date:&#39;medium&#39; }}
</code></pre>
<p>就这样，现在你已经有了一个专属推文页了！</p>
<h1>添加用户认证功能</h1><p>敬请期待……</p>
</div></div></div><div id="footer"><div class="container"><!-- Begin MailChimp Signup Form -->
<div id="mc_embed_signup">
<form action="//synthjs.us8.list-manage.com/subscribe/post?u=f8e920cca194c0c921f464fdc&amp;id=5c05f681a4" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>

<div class="mc-field-group" style="display: inline-block;">
  <label for="mce-EMAIL">Stay up to date on Synth's latest features and news:</label>
  <input type="email" value="" name="EMAIL" class="required email form-control" id="mce-EMAIL" placeholder="you@fancy-domain.io" style="width: inherit; display: inline-block;">
</div>
<input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button btn btn-default">
  <div id="mce-responses" class="clear">
    <div class="response" id="mce-error-response" style="display:none"></div>
    <div class="response" id="mce-success-response" style="display:none"></div>
  </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;"><input type="text" name="b_f8e920cca194c0c921f464fdc_5c05f681a4" tabindex="-1" value=""></div>
</form>
</div>

<!--End mc_embed_signup-->
<p>Synth was created with warm + fuzzy feelings by <a href="https://twitter.com/JonathanAbrams">Jon Abrams</a></p></div></div><script src="//cdn.jsdelivr.net/g/jquery@2.1,bootstrap@3.1"></script><script src="/bower_components/prismjs/prism.js"></script><script src="/js/main.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49733760-1', 'synthjs.com');
  ga('send', 'pageview');

</script>
</body></html>