<div class="language-toggle">
  语言 / Languages
  <ul>
    <li><a href="/tutorial/cn">简体中文</a></li>
    <li><a href="/tutorial">English</a></li>
  </ul>
</div>
<div id="intro"></div>
# Intro

This guide will walk you through the steps necessary to add some extra functionality to the default app generated by synth.

The default app created by synth is a very limited version of twitter. Out of the box it just displays a list of tweets.

This guide will walk you through:

1. Installing Synth
2. Creating your first project.

Then we'll add some missing functionality:

- The ability to publish new tweets.
- The ability to link to a particular tweet.
- The ability to tweet non-anonymously.

<div id="setup"></div>
# Setup

<div id="dependencies"></div>
## Dependencies

Before you get started with synth, there's a few extra things you need to install first:

- Node ver. 0.10.0 or higher - [Available for free here](http://nodejs.org)
- NPM ver. 1.3 or higher (It should automatically be installed with Node these days)
- MongoDB - [Available for free here](https://www.mongodb.org/) - Don't forget to launch it in the background after installing it.

<div id="install"></div>
## Install Synth

Synth is available using NPM. Install it globally using npm to access it from the command-line:

```bash
npm install -g synth
```

**Note**: You may need to do `sudo npm install -g synth` if you get any permission errors when attempting to install using the above command.

<div id="create-app"></div>
## Create a new app

```bash
synth new my_app
```

This will create a new folder called `my_app`, you can of course change `my_app` to anything you like.

```bash
cd my_app # Change the working directory to the root of your new web app
synth install -b # Install third-party back-end packages (using npm)
synth install -f # Install third-pary front-end packages (using bower)
```

Go into your new project and install any third-party back-end and front-end packages.

Even though you have already installed _synth_ globally, in order to use it on the command-line, each project needs its own copy of it. Running `synth install -b` will install it for you.

**Note**:

- Back-end packages will be installed into `my_app/back/node_modules`.
- Front-end packages will be installed into `my_app/front/bower_components`.

<div id="starting"></div>
## Starting the app

To start the app, just run `synth server` or `synth s`.

To start it in production mode (where all the assets are minified and concatenated) run `synth prod` or run `synth server` with the environment variables _NODE_ENV_ set to "production".

You can specify the port that the server will listen to by setting the _PORT_ environment variable or by using the _-p_ flag, e.g. `synth s -p 3001`. 3000 is the default port.

<div id="populate-db"></div>
## Pre-populate the DB

Once you point your browser to http://localhost:3000, you should hopefully see a blank page with a title in the centre saying "Tweets". But where are the tweets?

Luckily, a little script is included in your project that will populate the DB with randomly generated hipster tweets.

To generate these tweets run the following command in a different terminal:

```bash
node back/generateTweets.js
```

What a few seconds, then refresh the web app and hopefully you should see 20 tweets listed.

<div id="publish"></div>
# Add ability to "tweet"

It's great that we can now see existing tweets, but it'd be awesome if real people could tweet too.

Adding such a feature is done in three steps:

1. Creating a _post_ method on the back-end.
2. Creating a publish method in the _tweetsController_ on the front-end.
3. Adding a textarea and button to the view on the front-end.

<div id="create-post-method"></div>
## Creating a _post_ method

We need an API endpoint that when it's requested, will create a new entry in our database.

The way that endpoints are added in synth, is by creating a public method inside a the resource folder that the endpoint interacts with. In this case, we'll be adding a method called `post` inside a _.js_ file inside of the `back/resources/tweets/` folder.

**Note**: The name of the _.js_ file doesn't matter to synth, choose a name that suits your needs. The names of the folders inside of `back/resources/` on the other hand do matter, they determine the URL routes that synth listens to.

Add the following code to a new file located at `my_app/back/resources/tweets/createTweets.js`:

```javascript
exports.post = function (db, params) {
  if (!params.content) throw 422;

  return db.collection('tweets').insert({
    content: params.content.slice(0, 140),
    created_at: new Date()
  });
};
```

#### Explanation

You now have a request handler available at `/api/tweets` that responds to **POST** requests. The function declaration `exports.post = function (db, params)` specifies that this request handler depends on the _db_ and _params_ services (both are part of the default template). Synth will automatically inject the dependencies when the request handler is invoked. In this case, any parameter attached to the body of the incoming request, will be available through the _params_ object, and the _db_ object will provide the database connection.

If there's no _content_ field attached to the request, then it throws 422, which will sets the response code status to 422 and then return. On the other hand, if there is content being sent to the request, then it inserts a new document into the mongoDB.

You may now be wondering: Why is the function is returning the call to the DB? Synth has built-in support for promises. This means that if the request is a success (i.e. status 200), you can either just return the data that you want returned as JSON, or a promise representing that data. In this app, _db_ is provided by a library called [promised-mongo](https://github.com/gordonmleigh/promised-mongo), as you can see in `back/services/db.js`, the declaration of the _db_ service. It allows you to interact with mongo databases and returns a promise as a result. In this case, synth will wait for the promise to be resolved (i.e. for the data to be written to the DB), and then respond to the request with JSON that contains the new tweet.

Without synth's promise support feature and dependency injection, the request would need to look like this:

```javascript
exports.post = function (req, res) {
  if (!req.body.content) return res.send(422);

  req.db.collection('tweets').insert({
    content: req.body.content.slice(0, 140),
    created_at: new Date()
  }, function (tweet) {
    res.send( JSON.stringify(tweet) );
  });
};
```

The above code will still work, but it requires more lines of code. And as they say, more lines of code lead to more chances for bugs!

<div id="create-publish-method"></div>
## Creating a publish method on the _tweetsController_

Now that our back-end is ready and willing to add tweets to the DB upon request, we need to add the JS code on the front-end that makes the request.

Inside the _tweetsController_, found in `my_app/front/controllers/tweets.js` add the following:

```javascript
$scope.publish = function () {
  $http.post('/api/tweets', { content: $scope.newTweet })
  .success(function (tweet) {
    $scope.tweets.unshift(tweet);
  });
  $scope.newTweet = '';
};
```

You'll also need to add the _$http_ service to the controller (on line 2):

```javascript
.controller('tweetsController', function ($scope, $http, data) {
```

#### Explanation

If you're familiar with angularjs, then the above should be pretty clear. It fires off a POST request to `http://localhost:3000/api/tweets` with a JSON request (e.g. `{"content":"An example tweet"}`.

And just like synth, angularjs has built-in support for promises. The post request is a promise, and once it has successfully been resolved, it adds the tweet to the list of tweets to be shown to the user.

It also clears out the _newtweet_ field right away, before the http request is resolved, to prevent accidental double posting of the same tweet.

<div id="add-textarea-and-button"></div>
## Add a textarea and button for publishing tweets

Now we have front-end and back-end code for publishing tweets, all that remains is the UI for the user to enter their tweet and fire off the _publish_ method.

You'll find the main view that shows the list of global tweets at `my_app/front/html/tweets/getIndex.jade`.

Open it up and add the following code to the top of the file:

```jade
textarea(ng-model="newTweet")
button(ng-click="publish()", ng-disabled="newTweet.length == 0") Publish
```

#### Explanation

If you're not familiar with [jade](http://jade-lang.com/), it's a much nicer way to write HTML, once you get the hang of it.

The above jade code adds a textarea linked to the _newTweet_ angular model. It then adds a button that fires of the _publish_ method when clicked.

That's it, you can now publish new tweets!

<div id="enable-links-to-tweets"></div>
# Enable links to particular tweets

Seeing the list of tweets is nice but what happens if you find a really good one and want to share a link to it?

Adding such a feature is done in three steps:

1. Creating a _get_ method on the back-end.
2. Creating a new _tweetController_ on the front-end (note how the tweet is singular, not plural).
3. Adding a an html template for the new view.

<div id="create-get-method"></div>
## Creating the _GET_ method

If you open up `back/resources/tweets/getTweets.js` you'll see an existing API endpoint for getting a list of tweets.

To create a new API endpoint for getting a single tweet, declare a function attached to exports called `get`.

```javascript
exports.get = function (params, db) {
  // Return a promise that resolves to the requested tweet
  return db.collection('tweets').findOne({
    _id: db.ObjectId(params.id)
  });
}
```

#### Explanation

With a vanilla `get` request handler, an API endpoint will be created that will expect an ID.

For example, the above will now listen for requests at `/api/tweets/:id`.

The `params` service will then parse the URL and provide the id.

Note that `db.ObjectId` is a method used for converting a string into a db specific type. This method is specific to the db used in this example, MongoDB.

<div id="create-tweet-controller"></div>
## Create a new _tweetController_ and front-end route

We'll first need to add a new URL route to your app's AngularJS routes.

In `front/js/front-app.js` add another `.when` call to `$routeProvider`:

```javascript
…
$routeProvider
.when('/tweets', {
  templateUrl: '/html/tweets/getIndex.html',
  controller: 'tweetsController',
  resolve: {
    data: dataLoaderRunner
  }
})
.when('/tweets/:id', {
  templateUrl: '/html/tweets/get.html',
  controller: 'tweetController',
  resolve: {
    data: dataLoaderRunner
  }
})
…
```

This is so you're AngularJS app knows to invoke the `tweetController` when the specified URL pattern is observed.

Now you need to add the controller to your Angular app.

`front/js/controllers/tweets.js`:

```javascript
.controller('tweetsController', function ($scope, data) {
  $scope.tweets = data.tweets;
})
.controller('tweetController', function ($scope, data) {
  angular.extend($scope, data);
});
```

This copies the values from the returned API into the scope, so they can then be rendered in the view, which we'll make next.

<div id="create-tweet-view"></div>
## Create the _tweet_ view and add links

Create a new view html file:

`front/html/tweets/get.html`

```html
<div class="tweet">
  <div class="content">
    {{ content }}
  </div>
  <div class="date">
    {{ created_at | date:'medium' }}
  </div>
</div>
```

Then linkify the dates in the index view:

`front/html/tweets/getIndex.jade`

```javascript
ul.tweet-timeline
  li.tweet(ng-repeat="tweet in tweets")
    .content {{ tweet.content}}
    a(href="/tweets/{{ tweet._id }}")
      .date {{ tweet.created_at | date:'medium' }}
```

That's it, now you have dedicated tweet pages!

# Add user authentication

Coming soon…
